<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Closure</title>
  </head>
  <body>
    <button id="green">green</button>
    <button id="orange">Orange</button>
  </body>

  <script>
    // function along with its lexical scope forms a closure
    // Lexical scope is basically child function can access parents variable even after parent function
    // has completed execution, but parent can't access childs variables.
    // function outerFunction() {
    //   const name = "function";
    //   function innerFunction() {
    //     console.log(`this is inner ${name}`);
    //   }
    //   return innerFunction;
    // }
    // const inner = outerFunction();
    // inner();

    function outerFunction(name) {
      return function inner() {
        console.log(name);
      };
    }
    const outerName = outerFunction("Mozilla");
    console.log(outerName);
    outerName();

    //Passing variables through parameter
    function secret(name, age) {
      return function () {
        console.log(name, age);
      };
    }
    const Aquib = secret("AquibBhai", 27);
    const coding = secret("Aquib Loves coding");
    Aquib(); //output comes AquibBhai , 27
    coding(); //Aquib loves coding

    //Passing variables through parameter
    function adding(x, y) {
      return function () {
        console.log(x + y);
      };
    }
    const result = adding(5, 3);
    result();
  </script>

  <script>
        function clickHandler(color) {
          return function () {
            document.body.style.backgroundColor = `${color}`;
          };
        }

        document.getElementById("orange").onclick = clickHandler("orange");
        document.getElementById("green").onclick = clickHandler("green");

        //Alternate Method
        // window.onload = function () {
        //     function clickHandler(color) {
        //         return function () {
        //             document.body.style.backgroundColor = `${color}`;
        //         }
        //     }

        //     const orange = clickHandler("orange");
        //     orange(); // sets background color
        // }

        //setTimeout + closures -->
        function x() {
          for (let i = 0; i <= 4; i++) {
            setTimeout(function () {
              console.log(i);
            }, i * 1000);
          }
          console.log("Namaste Jaascript");
        }
        x();


    // closures in javascript : --->

    // What is a Closure?
    // A closure is a function that remembers the variables from its outer (lexical) scope, even after the outer function has finished executing.

    // Closure = Function + Its Lexical Environment

    // //Key Concept
    // function outer() {
    //   let name = "Aquib"; //accessible to inner function

    //   return function inner() {
    //     let name2 = "Aquib2";
    //     console.log(name); // ← this is closure
    //   };
    // console.log(name2);//cant access here due to scope

    // }

    // const greet = outer();
    // greet(); // Output: Aquib

    // Use Cases of Closures
    // 1)Data privacy  ---> Create private variables that can't be accessed directly.
    // 2)Function Factories ---> Create functions with preset behavior (e.g., multipliers).
    // 3) Event Handlers ---> Remember specific data when handling DOM events.
    // 4)Async Code ---> Keep context alive in setTimeout,Promises,fetch etc
    // 4)Memoization --> Cache values using inner state
    // 5)React Hooks ---> Closures power useState,useEffect etc.


    // for (var i = 1; i <= 3; i++) {//Global scope variable
    //   setTimeout(() => console.log(i), i * 1000);
    // }
    // // Output: 4, 4, 4
    // //let --> Block scope variable
    // if the same thing was done using let then output would have been
    // 1
    // 2
    // 3
  </script>
</html>
